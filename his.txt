     2:   COMMENT ""
    32:   PROGRAM "PROGRAM"
    32:        ID "sort"
    32:      SEMI ";"
    34:     CONST "CONST"
    35:   COMMENT "****************************************************************************"
    36:        ID "numkey"
    36:       EQU "="
    36:       INT "6"
    36:      SEMI ";"
    36:   COMMENT " number of characters in key "
    37:   COMMENT "****************************************************************************"
    38:        ID "maxselect"
    38:       EQU "="
    38:       INT "31"
    38:      SEMI ";"
    38:   COMMENT " 0..maxselect leaf nodes in selection tree "
    39:        ID "numsort"
    39:       EQU "="
    39:       INT "4"
    39:      SEMI ";"
    39:   COMMENT " 0..numsort temporary files for merging "
    42:      TYPE "TYPE"
    43:   COMMENT "****************************************************************************"
    44:        ID "keyindextype"
    44:       EQU "="
    44:       INT "1"
    44:    DOTDOT ".."
    44:        ID "numkey"
    44:      SEMI ";"
    44:   COMMENT " type used for index into key array "
    45:   COMMENT "**** keytype defines the type of the key field of the input records ****"
    46:        ID "keytype"
    46:       EQU "="
    46:    PACKED "PACKED"
    46:     ARRAY "ARRAY"
    46:    LBRACK "["
    46:        ID "keyindextype"
    46:    RBRACK "]"
    46:        OF "OF"
    46:        ID "char"
    46:      SEMI ";"
    47:   COMMENT "**** rectype defines the record type of the input and output files ****"
    48:        ID "rectype"
    48:       EQU "="
    49:    RECORD "RECORD"
    50:        ID "key"
    50:     COLON ":"
    50:        ID "keytype"
    50:      SEMI ";"
    50:   COMMENT "**** this field must be present ****"
    51:   COMMENT " other record components may appear in this record definition "
    52:        ID "eoff"
    52:     COLON ":"
    52:        ID "boolean"
    52:   COMMENT "**** this field must be present ****"
    53:       END "END"
    53:      SEMI ";"
    53:   COMMENT " rectype "
    54:   COMMENT "****************************************************************************"
    55:        ID "filetype"
    55:       EQU "="
    55:      FILE "FILE"
    55:        OF "OF"
    55:        ID "rectype"
    55:      SEMI ";"
    56:        ID "selectindextype"
    56:       EQU "="
    56:       INT "0"
    56:    DOTDOT ".."
    56:        ID "maxselect"
    56:      SEMI ";"
    57:        ID "switchtype"
    57:       EQU "="
    57:       INT "0"
    57:    DOTDOT ".."
    57:       INT "1"
    57:      SEMI ";"
    58:        ID "runtype"
    58:       EQU "="
    58:       INT "0"
    58:    DOTDOT ".."
    58:       INT "65535"
    58:      SEMI ";"
    59:        ID "fileindextype"
    59:       EQU "="
    60:    RECORD "RECORD"
    61:        ID "switch"
    61:     COLON ":"
    61:        ID "switchtype"
    61:      SEMI ";"
    62:        ID "num"
    62:     COLON ":"
    62:        ID "selectindextype"
    62:      SEMI ";"
    63:        ID "tmp"
    63:     COLON ":"
    63:        ID "boolean"
    64:       END "END"
    64:      SEMI ";"
    66:       VAR "VAR"
    68:        ID "infile"
    68:     COMMA ","
    68:        ID "outfile"
    68:     COLON ":"
    68:        ID "filetype"
    68:      SEMI ";"
    69:        ID "sortfile"
    69:     COLON ":"
    69:     ARRAY "ARRAY"
    69:    LBRACK "["
    69:       INT "0"
    69:    DOTDOT ".."
    69:       INT "1"
    69:     COMMA ","
    69:       INT "0"
    69:    DOTDOT ".."
    69:        ID "numsort"
    69:    RBRACK "]"
    69:        OF "OF"
    69:        ID "filetype"
    69:      SEMI ";"
    69:   COMMENT " work files for sort "
    70:        ID "sortfilename"
    70:     COLON ":"
    70:     ARRAY "ARRAY"
    70:    LBRACK "["
    70:       INT "0"
    70:    DOTDOT ".."
    70:       INT "1"
    70:     COMMA ","
    70:       INT "0"
    70:    DOTDOT ".."
    70:        ID "numsort"
    70:    RBRACK "]"
    70:        OF "OF"
    70:    PACKED "PACKED"
    70:     ARRAY "ARRAY"
    70:    LBRACK "["
    70:       INT "1"
    70:    DOTDOT ".."
    70:       INT "10"
    70:    RBRACK "]"
    70:        OF "OF"
    70:        ID "char"
    70:      SEMI ";"
    71:        ID "inindex"
    71:     COMMA ","
    71:        ID "outindex"
    71:     COLON ":"
    71:        ID "fileindextype"
    71:      SEMI ";"
    72:        ID "pass"
    72:     COLON ":"
    72:       INT "0"
    72:    DOTDOT ".."
    72:        ID "maxint"
    72:      SEMI ";"
    73:        ID "runcount"
    73:     COLON ":"
    73:        ID "runtype"
    73:      SEMI ";"
    74:        ID "infilename"
    74:     COMMA ","
    74:        ID "outfilename"
    74:     COLON ":"
    74:    PACKED "PACKED"
    74:     ARRAY "ARRAY"
    74:    LBRACK "["
    74:       INT "1"
    74:    DOTDOT ".."
    74:       INT "32"
    74:    RBRACK "]"
    74:        OF "OF"
    74:        ID "char"
    74:      SEMI ";"
    75:        ID "filesize"
    75:     COLON ":"
    75:        ID "integer"
    75:      SEMI ";"
    75:   COMMENT " size of the input file in blocks "
    76:        ID "reccount"
    76:     COLON ":"
    76:       INT "0"
    76:    DOTDOT ".."
    76:       INT "65535"
    76:      SEMI ";"
    76:   COMMENT " number of records in input file "
    78: PROCEDURE "PROCEDURE"
    78:        ID "switchfiles"
    78:    LPAREN "("
    78:        ID "nsort"
    78:     COLON ":"
    78:        ID "selectindextype"
    78:    RPAREN ")"
    78:      SEMI ";"
    79:   COMMENT " switches the roles of the temporary input & output files for next merge "
    80:       VAR "VAR"
    81:        ID "t"
    81:     COLON ":"
    81:        ID "switchtype"
    81:      SEMI ";"
    82:        ID "n"
    82:     COLON ":"
    82:        ID "selectindextype"
    82:      SEMI ";"
    83:     BEGIN "BEGIN"
    84:        IF "IF"
    84:        ID "nsort"
    84:        LT "<"
    84:       INT "1"
    84:      THEN "THEN"
    84:        ID "nsort"
    84:    ASSIGN ":="
    84:       INT "1"
    84:      SEMI ";"
    85:        ID "t"
    85:    ASSIGN ":="
    85:        ID "outindex"
    85:       DOT "."
    85:        ID "switch"
    85:      SEMI ";"
    86:        ID "outindex"
    86:       DOT "."
    86:        ID "switch"
    86:    ASSIGN ":="
    86:        ID "inindex"
    86:       DOT "."
    86:        ID "switch"
    86:      SEMI ";"
    87:        ID "inindex"
    87:       DOT "."
    87:        ID "switch"
    87:    ASSIGN ":="
    87:        ID "t"
    87:      SEMI ";"
    88:       FOR "FOR"
    88:        ID "n"
    88:    ASSIGN ":="
    88:       INT "0"
    88:        TO "TO"
    88:        ID "nsort"
    88:        DO "DO"
    89:     BEGIN "BEGIN"
    90:      WITH "WITH"
    90:        ID "outindex"
    90:        DO "DO"
    91:        IF "IF"
    91:        ID "tmp"
    91:      THEN "THEN"
    91:        ID "rewrite"
    91:    LPAREN "("
    91:        ID "sortfile"
    91:    LBRACK "["
    91:        ID "switch"
    91:     COMMA ","
    91:        ID "n"
    91:    RBRACK "]"
    91:     COMMA ","
    91:        ID "sortfilename"
    91:    LBRACK "["
    91:        ID "switch"
    91:     COMMA ","
    91:        ID "n"
    91:    RBRACK "]"
    91:    RPAREN ")"
    91:      SEMI ";"
    92:      WITH "WITH"
    92:        ID "inindex"
    92:        DO "DO"
    93:        IF "IF"
    93:        ID "tmp"
    93:      THEN "THEN"
    94:     BEGIN "BEGIN"
    95:        ID "close"
    95:    LPAREN "("
    95:        ID "sortfile"
    95:    LBRACK "["
    95:        ID "switch"
    95:     COMMA ","
    95:        ID "n"
    95:    RBRACK "]"
    95:    RPAREN ")"
    95:      SEMI ";"
    96:        ID "reset"
    96:    LPAREN "("
    96:        ID "sortfile"
    96:    LBRACK "["
    96:        ID "switch"
    96:     COMMA ","
    96:        ID "n"
    96:    RBRACK "]"
    96:     COMMA ","
    96:        ID "sortfilename"
    96:    LBRACK "["
    96:        ID "switch"
    96:     COMMA ","
    96:        ID "n"
    96:    RBRACK "]"
    96:    RPAREN ")"
    97:       END "END"
    98:       END "END"
    98:      SEMI ";"
    99:        ID "inindex"
    99:       DOT "."
    99:        ID "num"
    99:    ASSIGN ":="
    99:       INT "0"
    99:      SEMI ";"
   100:        ID "outindex"
   100:       DOT "."
   100:        ID "num"
   100:    ASSIGN ":="
   100:        ID "numsort"
   100:   COMMENT " incremented before first write "
   101:       END "END"
   101:      SEMI ";"
   101:   COMMENT " switchfiles "
   103: PROCEDURE "PROCEDURE"
   103:        ID "select"
   103:    LPAREN "("
   103:        ID "numselect"
   103:     COLON ":"
   103:        ID "selectindextype"
   103:      SEMI ";"
   103:       VAR "VAR"
   103:        ID "currun"
   103:     COLON ":"
   103:        ID "runtype"
   103:    RPAREN ")"
   103:      SEMI ";"
   104:   COMMENT ""
   118:      TYPE "TYPE"
   119:        ID "selectitemtype"
   119:       EQU "="
   120:    RECORD "RECORD"
   121:        ID "rec"
   121:     COLON ":"
   121:        ID "rectype"
   121:      SEMI ";"
   121:   COMMENT " record type to be sorted, including key "
   122:        ID "loser"
   122:     COLON ":"
   122:        ID "selectindextype"
   122:      SEMI ";"
   122:   COMMENT " internal node pointer to loser record "
   123:        ID "run"
   123:     COLON ":"
   123:        ID "runtype"
   123:      SEMI ";"
   123:   COMMENT " internal run number of record pointed to by loser "
   124:        ID "extptr"
   124:     COMMA ","
   124:        ID "intptr"
   124:     COLON ":"
   124:        ID "selectindextype"
   124:   COMMENT " pointers to nodes higher in tree "
   125:       END "END"
   125:      SEMI ";"
   127:       VAR "VAR"
   128:        ID "selectarray"
   128:     COLON ":"
   128:     ARRAY "ARRAY"
   128:    LBRACK "["
   128:        ID "selectindextype"
   128:    RBRACK "]"
   128:        OF "OF"
   128:        ID "selectitemtype"
   128:      SEMI ";"
   129:        ID "maxrun"
   129:     COLON ":"
   129:        ID "runtype"
   129:      SEMI ";"
   129:   COMMENT " run no. of last run output "
   130:        ID "lastkey"
   130:     COLON ":"
   130:        ID "keytype"
   130:      SEMI ";"
   130:   COMMENT " value of last key output "
   131:        ID "winptr"
   131:     COLON ":"
   131:        ID "selectindextype"
   131:      SEMI ";"
   131:   COMMENT " pointer to current winner "
   132:        ID "winrun"
   132:     COLON ":"
   132:        ID "runtype"
   132:      SEMI ";"
   132:   COMMENT " run no. of current winner "
   133:        ID "treeindex"
   133:     COLON ":"
   133:        ID "selectindextype"
   133:      SEMI ";"
   133:   COMMENT " used to move up the selection tree "
   134:        ID "done"
   134:     COLON ":"
   134:        ID "boolean"
   134:      SEMI ";"
   134:   COMMENT " controls main select loop "
   135:        ID "moveup"
   135:     COLON ":"
   135:        ID "boolean"
   135:      SEMI ";"
   135:   COMMENT " controls ascent of tree "
   137: PROCEDURE "PROCEDURE"
   137:        ID "selectinit"
   137:      SEMI ";"
   138:       VAR "VAR"
   139:        ID "t"
   139:     COLON ":"
   139:        ID "selectindextype"
   139:      SEMI ";"
   140:     BEGIN "BEGIN"
   141:        ID "reccount"
   141:    ASSIGN ":="
   141:       INT "0"
   141:      SEMI ";"
   141:   COMMENT " number of records "
   142:        ID "maxrun"
   142:    ASSIGN ":="
   142:       INT "0"
   142:      SEMI ";"
   143:        ID "currun"
   143:    ASSIGN ":="
   143:       INT "0"
   143:      SEMI ";"
   144:        ID "winptr"
   144:    ASSIGN ":="
   144:       INT "0"
   144:      SEMI ";"
   145:        ID "winrun"
   145:    ASSIGN ":="
   145:       INT "0"
   145:      SEMI ";"
   146:       FOR "FOR"
   146:        ID "t"
   146:    ASSIGN ":="
   146:       INT "0"
   146:        TO "TO"
   146:        ID "numselect"
   146:        DO "DO"
   147:      WITH "WITH"
   147:        ID "selectarray"
   147:    LBRACK "["
   147:        ID "t"
   147:    RBRACK "]"
   147:        DO "DO"
   148:     BEGIN "BEGIN"
   149:        ID "loser"
   149:    ASSIGN ":="
   149:        ID "t"
   149:      SEMI ";"
   150:        ID "run"
   150:    ASSIGN ":="
   150:       INT "0"
   150:      SEMI ";"
   151:        ID "extptr"
   151:    ASSIGN ":="
   151:    LPAREN "("
   151:        ID "numselect"
   151:      PLUS "+"
   151:       INT "1"
   151:      PLUS "+"
   151:        ID "t"
   151:    RPAREN ")"
   151:       DIV "DIV"
   151:       INT "2"
   151:      SEMI ";"
   152:        ID "intptr"
   152:    ASSIGN ":="
   152:        ID "t"
   152:       DIV "DIV"
   152:       INT "2"
   153:       END "END"
   154:       END "END"
   154:      SEMI ";"
   154:   COMMENT " selectinit "
   156: PROCEDURE "PROCEDURE"
   156:        ID "getfile"
   156:      SEMI ";"
   157:     BEGIN "BEGIN"
   158:      WITH "WITH"
   158:        ID "selectarray"
   158:    LBRACK "["
   158:        ID "winptr"
   158:    RBRACK "]"
   158:     COMMA ","
   158:        ID "inindex"
   158:        DO "DO"
   159:        IF "IF"
   159:        ID "tmp"
   160:      THEN "THEN"
   160:        ID "read"
   160:    LPAREN "("
   160:        ID "sortfile"
   160:    LBRACK "["
   160:        ID "switch"
   160:     COMMA ","
   160:        ID "winptr"
   160:    RBRACK "]"
   160:     COMMA ","
   160:        ID "rec"
   160:    RPAREN ")"
   161:      ELSE "ELSE"
   161:        ID "read"
   161:    LPAREN "("
   161:        ID "infile"
   161:     COMMA ","
   161:        ID "rec"
   161:    RPAREN ")"
   162:       END "END"
   162:      SEMI ";"
   162:   COMMENT " getfile "
   164: PROCEDURE "PROCEDURE"
   164:        ID "putfile"
   164:      SEMI ";"
   165:     BEGIN "BEGIN"
   166:      WITH "WITH"
   166:        ID "selectarray"
   166:    LBRACK "["
   166:        ID "winptr"
   166:    RBRACK "]"
   166:        DO "DO"
   167:     BEGIN "BEGIN"
   168:        ID "lastkey"
   168:    ASSIGN ":="
   168:        ID "rec"
   168:       DOT "."
   168:        ID "key"
   168:      SEMI ";"
   169:      WITH "WITH"
   169:        ID "outindex"
   169:        DO "DO"
   170:        IF "IF"
   170:        ID "tmp"
   171:      THEN "THEN"
   171:        ID "write"
   171:    LPAREN "("
   171:        ID "sortfile"
   171:    LBRACK "["
   171:        ID "switch"
   171:     COMMA ","
   171:        ID "num"
   171:    RBRACK "]"
   171:     COMMA ","
   171:        ID "rec"
   171:    RPAREN ")"
   172:      ELSE "ELSE"
   172:        ID "write"
   172:    LPAREN "("
   172:        ID "outfile"
   172:     COMMA ","
   172:        ID "rec"
   172:    RPAREN ")"
   173:       END "END"
   173:      SEMI ";"
   173:   COMMENT " with selectarray "
   174:        ID "reccount"
   174:    ASSIGN ":="
   174:        ID "reccount"
   174:      PLUS "+"
   174:       INT "1"
   175:       END "END"
   175:      SEMI ";"
   175:   COMMENT " putfile "
   177:  FUNCTION "FUNCTION"
   177:        ID "endfile"
   177:     COLON ":"
   177:        ID "boolean"
   177:      SEMI ";"
   178:     BEGIN "BEGIN"
   179:      WITH "WITH"
   179:        ID "inindex"
   179:        DO "DO"
   180:        IF "IF"
   180:        ID "tmp"
   181:      THEN "THEN"
   181:        ID "endfile"
   181:    ASSIGN ":="
   181:        ID "sortfile"
   181:    LBRACK "["
   181:        ID "switch"
   181:     COMMA ","
   181:        ID "winptr"
   181:    RBRACK "]"
   181:   UPARROW "^"
   181:       DOT "."
   181:        ID "eoff"
   182:      ELSE "ELSE"
   182:        ID "endfile"
   182:    ASSIGN ":="
   182:        ID "infile"
   182:   UPARROW "^"
   182:       DOT "."
   182:        ID "eoff"
   183:       END "END"
   183:      SEMI ";"
   183:   COMMENT " endfile "
   185: PROCEDURE "PROCEDURE"
   185:        ID "writeeofrecs"
   185:      SEMI ";"
   186:   COMMENT " write end-of-file records at the ends of the scratch files "
   187:       VAR "VAR"
   188:        ID "n"
   188:     COLON ":"
   188:        ID "selectindextype"
   188:      SEMI ";"
   189:        ID "numsel"
   189:     COLON ":"
   189:        ID "selectindextype"
   189:      SEMI ";"
   190:     BEGIN "BEGIN"
   191:        ID "numsel"
   191:    ASSIGN ":="
   191:        ID "numselect"
   191:      SEMI ";"
   192:        IF "IF"
   192:        ID "numsel"
   192:        GT ">"
   192:        ID "numsort"
   192:      THEN "THEN"
   192:        ID "numsel"
   192:    ASSIGN ":="
   192:        ID "numsort"
   192:      SEMI ";"
   193:      WITH "WITH"
   193:        ID "outindex"
   193:        DO "DO"
   194:        IF "IF"
   194:        ID "tmp"
   195:      THEN "THEN"
   196:       FOR "FOR"
   196:        ID "n"
   196:    ASSIGN ":="
   196:       INT "0"
   196:        TO "TO"
   196:        ID "numsel"
   196:        DO "DO"
   197:     BEGIN "BEGIN"
   198:        ID "sortfile"
   198:    LBRACK "["
   198:        ID "switch"
   198:     COMMA ","
   198:        ID "n"
   198:    RBRACK "]"
   198:   UPARROW "^"
   198:       DOT "."
   198:        ID "eoff"
   198:    ASSIGN ":="
   198:        ID "true"
   198:      SEMI ";"
   199:        ID "put"
   199:    LPAREN "("
   199:        ID "sortfile"
   199:    LBRACK "["
   199:        ID "switch"
   199:     COMMA ","
   199:        ID "n"
   199:    RBRACK "]"
   199:    RPAREN ")"
   200:       END "END"
   201:      ELSE "ELSE"
   202:     BEGIN "BEGIN"
   203:        ID "outfile"
   203:   UPARROW "^"
   203:       DOT "."
   203:        ID "eoff"
   203:    ASSIGN ":="
   203:        ID "true"
   203:      SEMI ";"
   204:        ID "put"
   204:    LPAREN "("
   204:        ID "outfile"
   204:    RPAREN ")"
   205:       END "END"
   206:       END "END"
   206:      SEMI ";"
   206:   COMMENT " writeeofrecs "
   208: PROCEDURE "PROCEDURE"
   208:        ID "exchangeloser"
   208:      SEMI ";"
   209:   COMMENT " exchange loser[treeindex] and winptr "
   210:       VAR "VAR"
   211:        ID "tempwin"
   211:     COLON ":"
   211:        ID "selectindextype"
   211:      SEMI ";"
   212:     BEGIN "BEGIN"
   213:      WITH "WITH"
   213:        ID "selectarray"
   213:    LBRACK "["
   213:        ID "treeindex"
   213:    RBRACK "]"
   213:        DO "DO"
   214:     BEGIN "BEGIN"
   215:        ID "tempwin"
   215:    ASSIGN ":="
   215:        ID "winptr"
   215:      SEMI ";"
   216:        ID "winptr"
   216:    ASSIGN ":="
   216:        ID "loser"
   216:      SEMI ";"
   217:        ID "loser"
   217:    ASSIGN ":="
   217:        ID "tempwin"
   218:       END "END"
   219:       END "END"
   219:      SEMI ";"
   219:   COMMENT " exchangeloser "
   221: PROCEDURE "PROCEDURE"
   221:        ID "exchangerun"
   221:      SEMI ";"
   222:   COMMENT " exchange current run no. and winrun "
   223:       VAR "VAR"
   224:        ID "temprun"
   224:     COLON ":"
   224:        ID "runtype"
   224:      SEMI ";"
   225:     BEGIN "BEGIN"
   226:      WITH "WITH"
   226:        ID "selectarray"
   226:    LBRACK "["
   226:        ID "treeindex"
   226:    RBRACK "]"
   226:        DO "DO"
   227:     BEGIN "BEGIN"
   228:        ID "temprun"
   228:    ASSIGN ":="
   228:        ID "winrun"
   228:      SEMI ";"
   229:        ID "winrun"
   229:    ASSIGN ":="
   229:        ID "run"
   229:      SEMI ";"
   230:        ID "run"
   230:    ASSIGN ":="
   230:        ID "temprun"
   231:       END "END"
   232:       END "END"
   232:      SEMI ";"
   232:   COMMENT " exchangerunno "
   234:     BEGIN "BEGIN"
   234:   COMMENT " select "
   235:        IF "IF"
   235:        ID "numselect"
   235:        LT "<"
   235:       INT "1"
   235:      THEN "THEN"
   235:        ID "numselect"
   235:    ASSIGN ":="
   235:       INT "1"
   235:      SEMI ";"
   236:        ID "selectinit"
   236:      SEMI ";"
   237:        ID "done"
   237:    ASSIGN ":="
   237:        ID "false"
   237:      SEMI ";"
   238:     WHILE "WHILE"
   238:       NOT "NOT"
   238:        ID "done"
   238:        DO "DO"
   239:     BEGIN "BEGIN"
   240:     WHILE "WHILE"
   240:        ID "winrun"
   240:       EQU "="
   240:        ID "currun"
   240:        DO "DO"
   241:     BEGIN "BEGIN"
   242:        IF "IF"
   242:        ID "winrun"
   242:        NE "<>"
   242:       INT "0"
   242:      THEN "THEN"
   242:        ID "putfile"
   242:      SEMI ";"
   243:        IF "IF"
   243:        ID "endfile"
   244:      THEN "THEN"
   244:        ID "winrun"
   244:    ASSIGN ":="
   244:        ID "maxint"
   244:   COMMENT " make permanently inaccessible "
   245:      ELSE "ELSE"
   246:     BEGIN "BEGIN"
   247:        ID "getfile"
   247:      SEMI ";"
   248:        IF "IF"
   248:    LPAREN "("
   248:        ID "winrun"
   248:       EQU "="
   248:       INT "0"
   248:    RPAREN ")"
   248:        OR "OR"
   248:    LPAREN "("
   248:        ID "selectarray"
   248:    LBRACK "["
   248:        ID "winptr"
   248:    RBRACK "]"
   248:       DOT "."
   248:        ID "rec"
   248:       DOT "."
   248:        ID "key"
   248:        LT "<"
   248:        ID "lastkey"
   248:    RPAREN ")"
   248:      THEN "THEN"
   249:     BEGIN "BEGIN"
   250:        ID "winrun"
   250:    ASSIGN ":="
   250:        ID "winrun"
   250:      PLUS "+"
   250:       INT "1"
   250:      SEMI ";"
   251:        IF "IF"
   251:        ID "winrun"
   251:        GT ">"
   251:        ID "maxrun"
   251:      THEN "THEN"
   251:        ID "maxrun"
   251:    ASSIGN ":="
   251:        ID "winrun"
   252:       END "END"
   253:       END "END"
   253:      SEMI ";"
   254:        ID "treeindex"
   254:    ASSIGN ":="
   254:        ID "selectarray"
   254:    LBRACK "["
   254:        ID "winptr"
   254:    RBRACK "]"
   254:       DOT "."
   254:        ID "extptr"
   254:      SEMI ";"
   254:   COMMENT " chase up tree "
   255:        ID "moveup"
   255:    ASSIGN ":="
   255:        ID "true"
   255:      SEMI ";"
   256:     WHILE "WHILE"
   256:        ID "moveup"
   256:        DO "DO"
   257:      WITH "WITH"
   257:        ID "selectarray"
   257:    LBRACK "["
   257:        ID "treeindex"
   257:    RBRACK "]"
   257:        DO "DO"
   258:     BEGIN "BEGIN"
   259:        IF "IF"
   259:        ID "run"
   259:        LT "<"
   259:        ID "winrun"
   260:      THEN "THEN"
   261:     BEGIN "BEGIN"
   262:        ID "exchangeloser"
   262:      SEMI ";"
   263:        ID "exchangerun"
   264:       END "END"
   265:      ELSE "ELSE"
   265:        IF "IF"
   265:    LPAREN "("
   265:        ID "run"
   265:       EQU "="
   265:        ID "winrun"
   265:    RPAREN ")"
   266:       AND "AND"
   266:    LPAREN "("
   266:        ID "selectarray"
   266:    LBRACK "["
   266:        ID "loser"
   266:    RBRACK "]"
   266:       DOT "."
   266:        ID "rec"
   266:       DOT "."
   266:        ID "key"
   267:        LT "<"
   267:        ID "selectarray"
   267:    LBRACK "["
   267:        ID "winptr"
   267:    RBRACK "]"
   267:       DOT "."
   267:        ID "rec"
   267:       DOT "."
   267:        ID "key"
   267:    RPAREN ")"
   268:      THEN "THEN"
   268:        ID "exchangeloser"
   268:      SEMI ";"
   269:        IF "IF"
   269:        ID "treeindex"
   269:       EQU "="
   269:       INT "1"
   270:      THEN "THEN"
   270:        ID "moveup"
   270:    ASSIGN ":="
   270:        ID "false"
   271:      ELSE "ELSE"
   271:        ID "treeindex"
   271:    ASSIGN ":="
   271:        ID "intptr"
   272:       END "END"
   273:       END "END"
   273:      SEMI ";"
   274:        IF "IF"
   274:        ID "winrun"
   274:        GT ">"
   274:        ID "maxrun"
   275:      THEN "THEN"
   276:     BEGIN "BEGIN"
   277:        ID "writeeofrecs"
   277:      SEMI ";"
   278:        ID "done"
   278:    ASSIGN ":="
   278:        ID "true"
   279:       END "END"
   280:      ELSE "ELSE"
   281:     BEGIN "BEGIN"
   282:        ID "currun"
   282:    ASSIGN ":="
   282:        ID "winrun"
   282:      SEMI ";"
   283:      WITH "WITH"
   283:        ID "outindex"
   283:        DO "DO"
   283:        ID "num"
   283:    ASSIGN ":="
   283:    LPAREN "("
   283:        ID "num"
   283:      PLUS "+"
   283:       INT "1"
   283:    RPAREN ")"
   283:       MOD "MOD"
   283:    LPAREN "("
   283:        ID "numsort"
   283:      PLUS "+"
   283:       INT "1"
   283:    RPAREN ")"
   284:   COMMENT " switch to next output scratch file "
   285:       END "END"
   286:       END "END"
   286:   COMMENT " while not done "
   287:       END "END"
   287:      SEMI ";"
   287:   COMMENT " select "
   289: PROCEDURE "PROCEDURE"
   289:        ID "sortexit"
   289:      SEMI ";"
   290:       VAR "VAR"
   291:        ID "k"
   291:     COLON ":"
   291:        ID "switchtype"
   291:      SEMI ";"
   292:        ID "l"
   292:     COLON ":"
   292:        ID "selectindextype"
   292:      SEMI ";"
   293:     BEGIN "BEGIN"
   294:       FOR "FOR"
   294:        ID "k"
   294:    ASSIGN ":="
   294:       INT "0"
   294:        TO "TO"
   294:       INT "1"
   294:        DO "DO"
   295:       FOR "FOR"
   295:        ID "l"
   295:    ASSIGN ":="
   295:       INT "0"
   295:        TO "TO"
   295:        ID "numsort"
   295:        DO "DO"
   296:        ID "delete"
   296:    LPAREN "("
   296:        ID "sortfile"
   296:    LBRACK "["
   296:        ID "k"
   296:     COMMA ","
   296:        ID "l"
   296:    RBRACK "]"
   296:    RPAREN ")"
   297:       END "END"
   297:      SEMI ";"
   297:   COMMENT " sortexit "
   299: PROCEDURE "PROCEDURE"
   299:        ID "sortinit"
   299:      SEMI ";"
   300:       VAR "VAR"
   301:        ID "k"
   301:     COLON ":"
   301:        ID "switchtype"
   301:      SEMI ";"
   302:        ID "l"
   302:     COLON ":"
   302:        ID "selectindextype"
   302:      SEMI ";"
   303:     BEGIN "BEGIN"
   304:       FOR "FOR"
   304:        ID "k"
   304:    ASSIGN ":="
   304:       INT "0"
   304:        TO "TO"
   304:       INT "1"
   304:        DO "DO"
   305:       FOR "FOR"
   305:        ID "l"
   305:    ASSIGN ":="
   305:       INT "0"
   305:        TO "TO"
   305:        ID "numsort"
   305:        DO "DO"
   306:     BEGIN "BEGIN"
   307:        ID "sortfilename"
   307:    LBRACK "["
   307:        ID "k"
   307:     COMMA ","
   307:        ID "l"
   307:    RBRACK "]"
   307:    ASSIGN ":="
   307:    STRING "SORT  .TMP"
   307:      SEMI ";"
   308:        ID "sortfilename"
   308:    LBRACK "["
   308:        ID "k"
   308:     COMMA ","
   308:        ID "l"
   308:    RBRACK "]"
   308:    LBRACK "["
   308:       INT "5"
   308:    RBRACK "]"
   308:    ASSIGN ":="
   308:        ID "chr"
   308:    LPAREN "("
   308:        ID "k"
   308:      PLUS "+"
   308:        ID "ord"
   308:    LPAREN "("
   308:    STRING "0"
   308:    RPAREN ")"
   308:    RPAREN ")"
   308:      SEMI ";"
   309:        ID "sortfilename"
   309:    LBRACK "["
   309:        ID "k"
   309:     COMMA ","
   309:        ID "l"
   309:    RBRACK "]"
   309:    LBRACK "["
   309:       INT "6"
   309:    RBRACK "]"
   309:    ASSIGN ":="
   309:        ID "chr"
   309:    LPAREN "("
   309:        ID "l"
   309:      PLUS "+"
   309:        ID "ord"
   309:    LPAREN "("
   309:    STRING "0"
   309:    RPAREN ")"
   309:    RPAREN ")"
   309:      SEMI ";"
   310:        ID "rewrite"
   310:    LPAREN "("
   310:        ID "sortfile"
   310:    LBRACK "["
   310:        ID "k"
   310:     COMMA ","
   310:        ID "l"
   310:    RBRACK "]"
   310:     COMMA ","
   310:        ID "sortfilename"
   310:    LBRACK "["
   310:        ID "k"
   310:     COMMA ","
   310:        ID "l"
   310:    RBRACK "]"
   310:    RPAREN ")"
   311:       END "END"
   311:      SEMI ";"
   312:      WITH "WITH"
   312:        ID "inindex"
   312:        DO "DO"
   313:     BEGIN "BEGIN"
   314:        ID "switch"
   314:    ASSIGN ":="
   314:       INT "1"
   314:      SEMI ";"
   315:        ID "tmp"
   315:    ASSIGN ":="
   315:        ID "false"
   315:   COMMENT " initial input from infile "
   316:       END "END"
   316:      SEMI ";"
   317:      WITH "WITH"
   317:        ID "outindex"
   317:        DO "DO"
   318:     BEGIN "BEGIN"
   319:        ID "switch"
   319:    ASSIGN ":="
   319:       INT "0"
   319:      SEMI ";"
   320:        ID "num"
   320:    ASSIGN ":="
   320:        ID "numsort"
   320:      SEMI ";"
   321:        ID "tmp"
   321:    ASSIGN ":="
   321:        ID "true"
   321:   COMMENT " output goes to temp sort files "
   322:       END "END"
   322:      SEMI ";"
   323:       END "END"
   323:      SEMI ";"
   323:   COMMENT " sortinit "
   325: PROCEDURE "PROCEDURE"
   325:        ID "printstats"
   325:      SEMI ";"
   326:     BEGIN "BEGIN"
   327:        ID "write"
   327:    LPAREN "("
   327:        ID "runcount"
   327:     COLON ":"
   327:       INT "4"
   327:     COMMA ","
   327:    STRING " runs, "
   327:    RPAREN ")"
   327:      SEMI ";"
   328:        ID "write"
   328:    LPAREN "("
   328:        ID "reccount"
   328:     COLON ":"
   328:       INT "6"
   328:     COMMA ","
   328:    STRING " records"
   328:    RPAREN ")"
   328:      SEMI ";"
   329:        ID "writeln"
   330:       END "END"
   330:      SEMI ";"
   330:   COMMENT " printstats "
   332:     BEGIN "BEGIN"
   332:   COMMENT " main "
   333:        ID "write"
   333:    LPAREN "("
   333:    STRING "Input file: "
   333:    RPAREN ")"
   333:      SEMI ";"
   334:        ID "readln"
   334:    LPAREN "("
   334:        ID "infilename"
   334:    RPAREN ")"
   334:      SEMI ";"
   335:        ID "reset"
   335:    LPAREN "("
   335:        ID "infile"
   335:     COMMA ","
   335:        ID "infilename"
   335:     COMMA ","
   335:     COMMA ","
   335:        ID "filesize"
   335:    RPAREN ")"
   335:      SEMI ";"
   336:        IF "IF"
   336:        ID "filesize"
   336:        LT "<"
   336:       INT "0"
   336:      THEN "THEN"
   336:        ID "writeln"
   336:    LPAREN "("
   336:    STRING "  File is non-existent or protected . . ."
   336:    RPAREN ")"
   337:      ELSE "ELSE"
   337:        IF "IF"
   337:        ID "filesize"
   337:       EQU "="
   337:       INT "0"
   337:      THEN "THEN"
   337:        ID "writeln"
   337:    LPAREN "("
   337:    STRING "  File is empty . . ."
   337:    RPAREN ")"
   338:      ELSE "ELSE"
   339:     BEGIN "BEGIN"
   340:        ID "write"
   340:    LPAREN "("
   340:    STRING "Output file: "
   340:    RPAREN ")"
   340:      SEMI ";"
   341:        ID "readln"
   341:    LPAREN "("
   341:        ID "outfilename"
   341:    RPAREN ")"
   341:      SEMI ";"
   342:        ID "writeln"
   342:      SEMI ";"
   343:        ID "sortinit"
   343:      SEMI ";"
   343:   COMMENT " initialize scratch files "
   344:        ID "pass"
   344:    ASSIGN ":="
   344:       INT "0"
   344:      SEMI ";"
   345:   COMMENT ""
   348:        ID "select"
   348:    LPAREN "("
   348:        ID "maxselect"
   348:     COMMA ","
   348:        ID "runcount"
   348:    RPAREN ")"
   348:      SEMI ";"
   348:   COMMENT " generate first runs to temp sort files "
   349:   COMMENT ""
   352:        ID "inindex"
   352:       DOT "."
   352:        ID "tmp"
   352:    ASSIGN ":="
   352:        ID "true"
   352:      SEMI ";"
   352:   COMMENT " subsequent input is from temp sort files "
   353:     WHILE "WHILE"
   353:        ID "runcount"
   353:        GT ">"
   353:        ID "numsort"
   353:      PLUS "+"
   353:       INT "1"
   353:        DO "DO"
   354:     BEGIN "BEGIN"
   355:        ID "pass"
   355:    ASSIGN ":="
   355:        ID "pass"
   355:      PLUS "+"
   355:       INT "1"
   355:      SEMI ";"
   356:   COMMENT ""
   359:        ID "switchfiles"
   359:    LPAREN "("
   359:        ID "numsort"
   359:    RPAREN ")"
   359:      SEMI ";"
   359:   COMMENT " switch roles of input & output sort files "
   360:        ID "select"
   360:    LPAREN "("
   360:        ID "numsort"
   360:     COMMA ","
   360:        ID "runcount"
   360:    RPAREN ")"
   360:      SEMI ";"
   360:   COMMENT " merge "
   361:   COMMENT ""
   364:       END "END"
   364:      SEMI ";"
   365:   COMMENT ""
   368:        ID "switchfiles"
   368:    LPAREN "("
   368:        ID "runcount"
   368:     MINUS "-"
   368:       INT "1"
   368:    RPAREN ")"
   368:      SEMI ";"
   369:        ID "rewrite"
   369:    LPAREN "("
   369:        ID "outfile"
   369:     COMMA ","
   369:        ID "outfilename"
   369:    RPAREN ")"
   369:      SEMI ";"
   370:        ID "outindex"
   370:       DOT "."
   370:        ID "tmp"
   370:    ASSIGN ":="
   370:        ID "false"
   370:      SEMI ";"
   370:   COMMENT " final output goes to outfile "
   371:        ID "select"
   371:    LPAREN "("
   371:        ID "runcount"
   371:     MINUS "-"
   371:       INT "1"
   371:     COMMA ","
   371:        ID "runcount"
   371:    RPAREN ")"
   371:      SEMI ";"
   371:   COMMENT " final merge "
   372:        ID "sortexit"
   372:      SEMI ";"
   372:   COMMENT " delete temporary sort files "
   373:   COMMENT ""
   376:       END "END"
   377:       END "END"
   377:       DOT "."
   378:       EOF "*EOF*"

Identifier Cross Reference Table
--------------------------------
boolean                           52    63   134   135   177
char                              46    70    74
chr                              308   309
close                             95
currun                           103   143   240   282
delete                           296
done                             134   237   238   278
endfile                          177   181   182   243
eoff                              52   181   182   198   203
exchangeloser                    208   262   268
exchangerun                      221   263
extptr                           124   151   254
false                            237   270   315   370
fileindextype                     59    71
filesize                          75   335   336   337
filetype                          55    68    69
getfile                          156   247
infile                            68   161   182   335
infilename                        74   334   335
inindex                           71    86    87    92    99   158   179
                                 312   352
integer                           75
intptr                           124   152   271
k                                291   294   296   301   304   307   308
                                 309   310
key                               50   168   248   266   267
keyindextype                      44    46
keytype                           46    50   130
l                                292   295   296   302   305   307   308
                                 309   310
lastkey                          130   168   248
loser                            122   149   216   217   266
maxint                            72   244
maxrun                           129   142   251   274
maxselect                         38    56   348
moveup                           135   255   256   270
n                                 82    88    91    95    96   188   196
                                 198   199
nsort                             78    84    88
num                               62    99   100   171   283   320
numkey                            36    44
numsel                           189   191   192   196
numselect                        103   146   151   191   235
numsort                           39    69    70   100   192   283   295
                                 305   320   353   359   360
ord                              308   309
outfile                           68   172   203   204   369
outfilename                       74   341   369
outindex                          71    85    86    90   100   169   193
                                 283   317   370
pass                              72   344   355
printstats                       325
put                              199   204
putfile                          164   242
read                             160   161
readln                           334   341
rec                              121   160   161   168   171   172   248
                                 266   267
reccount                          76   141   174   328
rectype                           48    55   121
reset                             96   335
rewrite                           91   310   369
run                              123   150   229   230   259   265
runcount                          73   327   348   353   360   368   371
runtype                           58    73   103   123   129   132   224
select                           103   348   360   371
selectarray                      128   147   158   166   213   226   248
                                 254   257   266   267
selectindextype                   56    62    78    82   103   122   124
                                 128   131   133   139   188   189   211
                                 292   302
selectinit                       137   236
selectitemtype                   119   128
sort                              32
sortexit                         289   372
sortfile                          69    91    95    96   160   171   181
                                 198   199   296   310
sortfilename                      70    91    96   307   308   309   310
sortinit                         299   343
switch                            61    85    86    87    91    95    96
                                 160   171   181   198   199   314   319
switchfiles                       78   359   368
switchtype                        57    61    81   291   301
t                                 81    85    87   139   146   147   149
                                 151   152
temprun                          224   228   230
tempwin                          211   215   217
tmp                               63    91    93   159   170   180   194
                                 315   321   352   370
treeindex                        133   213   226   254   257   269   271
true                             198   203   255   278   321   352
winptr                           131   144   158   160   166   181   215
                                 216   248   254   267
winrun                           132   145   228   229   240   242   244
                                 248   250   251   259   265   274   282
write                            171   172   327   328   333   340
writeeofrecs                     185   277
writeln                          329   336   337   342
